# Типизированные свойства в PHP 7.4
> Перевод статьи "Typed properties in PHP 7.4"
> Оригинал: https://stitcher.io/blog/typed-properties-in-php-74

Типизированные свойства классов были добавлены в  PHP 7.4, и предоставляют  значительное улучшение системы типов PHP. Эти изменения полностью приняты и не ломают предыдущие версии.

В этом посте мы подробнее изучим это новшество, но сначала перечислим важные моменты:
- Эти новшества доступны в PHP 7.4, выход которого запланирован на ноябрь 2019
- Они доступны только внутри классов, и требуют модификатор доступа: **public**, **protected** или **private**; или **var**
- Разрешено использовать все типы данных, кроме **void** и **callable**

Вот так это выглядит в действии:
 ```
class Foo
{
    public int $a;
    public ?string $b = 'foo';
    private Foo $prop;
    protected static string $static = 'default';
}
```
## Неинициализировано
Перед тем как начать обзор, в первую очередь надо поговорить про один важный аспект у типизированных свойств .

На первый взгляд, следющий код покажется невалидным, но это не так:
```php
class Foo
{
    public int $bar;
}
$foo = new Foo;

```
Хоть и значение `$foo->bar` не является числом после создания объекта от `Foo`, PHP выбросит ошибку только при доступе к `$foo->bar`:
```
var_dump($foo->bar);

Fatal error: Uncaught Error: Typed property Foo::$bar 
must not be accessed before initialization
```
> Прим. переводчика: RFC говорит об ошибке типа TypeError, а не Fatal error

Как вы поняли из сообщения об ошибке, теперь есть новый вид "состояния переменной": **uninitialized / неинициализированно**.

> Прим. переводчика: ошибка не будет выброшена, если указан __get()

Если  `$foo->bar` не задан тип, значением будет просто null. Однако, типизированные свойства тоже могут быть пустыми (nullable), поэтому нельзя определить, было ли свойство указано как nullable или значение свойства упущено. Вот почему было добавлено состояние "uninitialized".

```php
var_dump($foo);

object(Foo)#1 (0) {
  ["bar"] =>
    uninitialized(int)
}
```

Есть 4 важных моментов, которые надо помнить при работы со свойствами типа **uninitialized**:
- Вы не можете читать неинициализированные свойства, это приведет к ошибке fatal error.
- Так как состояние **uninitialized** проверяется только при доступе к свойству, вы можете создавать обьект с неинициализированные свойствами, даже если свойство не может быть пустым.
- Вы можете установить значение неинициализированному свойству, перед тем как прочитать его.
- Применение `unset()` на типизированное свойство, вернет его в состояние **uninitialized**, тогда как `unset()` на нетипизированное свойство установит значение null.

Обратите внимание, что следующий код, где неинициализированное, не null свойство было установлено только после создания обьекта, является валидным
```php
class Foo
{
    public int $a;
}

$foo = new Foo;
$foo->a = 1;
```
Проверка на состояние **uninitialized** выполняется только чтении свойства, а проверка на тип выполняется при записи. Это означает, что вы можете быть уверены, что невалидный тип никогда не будет значением свойства.

### Дефолтные значения и конструкторы
Давайте подближе взглянем как можно инициализировать типизированные значения. В случае со скалярными типами можно указать значение по умолчанию:
```php
class Foo
{
    public int $bar = 4;
    public ?string $baz = null;
    public array $list = [1, 2, 3];
}
```
Заметьте, что вы можете использовать null как дефолтное значение если тип nullable. Это кажется очевидным, но есть некоторое устаревшее поведение с параметрами по умолчанию, где допускается следующее:
```php
function passNull(int $i = null)
{ /* … */ }

passNull(null);
```
К счастью, такое запутывающее поведение недопустимо в типизированных свойствах.

Также обратите внимание, что у типов обьект или класс не может быть дефолтных значений. Используйте конструктор, для того, чтобы установить для них значения по умолчанию.

Очевидным местом для инициализации типизированных значений, конечно же, является конструктор:
```php
class Foo
{
    private int $a;

    public function __construct(int $a)
    {
        $this->a = $a;
    }
}
```
Но также помните, что я упоминал ранее: можно писать в неинициализированное свойство вне конструктора. Пока свойство не прочитано, проверка на **uninitialized** не выполнится.

### Типы типов
Так что именно может быть типом? Я уже упоминал, что типизированные свойства будут работать только в классах (пока что), и они нуждаются в модификаторах доступа или в ключевом слове var перед ними.

Все типы кроме void и callable могут быть использованы как типы свойств.

Потому что void это отсутствие значения, не имеет смысла использовать его как тип значения. А с callable есть небольшой нюанс.

К примеру, callable в PHP можно написать так:

```php
$callable = [$this, 'method'];
```
Скажем, у вас есть следующий (не рабочий) код:
```php
class Foo
{
    public callable $callable;

    public function __construct(callable $callable)
    { /* … */ }
}

class Bar
{
    public Foo $foo;

    public function __construct()
    {
        $this->foo = new Foo([$this, 'method'])
    }

    private function method()
    { /* … */ }
}

$bar = new Bar;

($bar->foo->callable)();
```
В этом примере $callable ссылается к приватному Bar::method(), но вызывается в контексте Foo. Из-за этой проблемы было решено не добавлять поддержку callable.

Это не страшно, т.к замыкания это допустимый тип, который помнит контекст $this, в котором был создан.

Итого, список всех доступных типов:
- bool
- int
- float
- string
- array
- iterable
- object
- ? (nullable)
- self & parent
- Классы и интерфейсы

### Приведение типов и строгие типы
PHP, является динамическим языком, за что мы его любим и ненавидим, будет пытаться приводить или преобразовывать типы, когда это возможно. Скажем, вы передаете строку туда, где ожидается число, и PHP попытается преобразовать эту строку:
```php
function coerce(int $i)
{ /* … */ }

coerce('1'); // 1
```
Те же принципы применяются к типизированным свойствам. Следующий код валиден и преобразует  '1' в 1.
```php
class Bar
{
    public int $i;
}

$bar = new Bar;
$bar->i = '1'; // 1
```
Вы можете отключить такое поведение, если оно вам не нравится:
```php
declare(strict_types=1);

$bar = new Bar;
$bar->i = '1'; // 1
```
> Fatal error: Uncaught TypeError: 
Typed property Bar::$i must be int, string used

### Type variance and inheritance
Хотя в PHP 7.4 улучшена ковариантность типов, типизированные свойства все еще инварианты. Это означает, что следующий код не валиден:
```php
class A {}
class B extends A {}

class Foo
{
    public A $prop;
}

class Bar extends Foo
{
    public B $prop;
}
```
> Fatal error: Type of Bar::$prop must be A (as in class Foo)

Если пример выше не убедил вас, взгляните на следующий код:
```php
class Foo
{
    public self $prop;
}

class Bar extends Foo
{
    public self $prop;
}
```
PHP за кулисами заменит self на конкретный класс, на который он ссылается, перед запуском кода. Это означает, что в этом примере будет выброшена такая же ошибка. Ниже, единственный способ обойти это:

```php
class Foo
{
    public Foo $prop;
}

class Bar extends Foo
{
    public Foo $prop;
}
```
Говоря о наследовании, вам может быть трудно придумать хорошие примеры перезаписывающие типы унаследованных свойств.

Хотя, стоит отметить, что можно изменить тип унаследованного свойства, но только если модификатор доступа также изменится с private на protected или public.
Следующий код валиден:

```php
class Foo
{
    private int $prop;
}

class Bar extends Foo
{
    public string $prop;
}
```
Однако, менять тип с nullable на non-nullable и обратно не разрешено.

```php
class Foo
{
    public int $a;
    public ?int $b;
}

class Bar extends Foo
{
    public ?int $a;
    public int $b;
}
```

> Fatal error: Type of Bar::$a must be int (as in class Foo)

### Еще кое-что
Как я говорил в начале поста, типизированные свойства это значительное новшество в PHP. О них можно еще много чего сказать, я предлагаю вам ознакомится с RFC, чтобы узнать больше деталей.